<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>HistoMap</title>
		<link rel="stylesheet" href="./styles.css" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300;400&display=swap" rel="stylesheet" />
		<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@1,800&display=swap" rel="stylesheet" />
	</head>
	<body>
		<div class="map-container"></div>
		<div class="date-container">
			<h2 id="current-year"></h2>
			<
		</div>
		<div id="myModal" class="modal">
			<div class="modal-content">
				<span><h4 id="book-title">Book</h4><p id="count" class="muted"></p></span>
				<p id="description">
					<ol id="titles">
					</ol>
				</p>
				<hr />
				<p id="tag" class="muted">Polska, moskwa</p>
			</div>
		</div>
		<script src="https://d3js.org/d3.v6.js"></script>
		<script src="https://unpkg.com/topojson@3"></script>
		<!-- Create an element where the map will take place -->
		<script>
			const currentYearElement = document.getElementById('current-year');
			const bookTitle = document.getElementById('book-title');
			const description = document.getElementById('description');
			const tag = document.getElementById('tag');
			const count = document.getElementById('count');
			var modal = document.getElementById('myModal');
			var btn = document.getElementById('myBtn');

			const CIRCLE_SIZE = 25;
			const INITIAL_TIMEOUT = 100;
			let currentYearIndex = 0;
			let g = null;
			let data;
			let transform = null;

			const renderModalWithBookInfo = function (book) {};
			// const create

			const getNextYear = function (element, years) {
				let currentTimeout = INITIAL_TIMEOUT;

				if (currentYearIndex === years.length) {
					currentYearIndex = 0;
				}
				if (currentYearIndex === years.length - 1 || currentYearIndex === 0) {
					timeout = +3000;
				}
				element.textContent = years[currentYearIndex];
				if (g != null) {
					let prevFill;
					let circleSize = transform ? CIRCLE_SIZE / transform.k : CIRCLE_SIZE;
					g.selectAll('a').remove();
					g.selectAll('circle')

						.data(data[years[currentYearIndex]])
						.enter()
						.append('a')
						.append('circle')
						.attr('class', 'marker')
						.attr('cx', function ({ coordinates }) {
							return projection(coordinates)[0];
						})
						.attr('cy', function ({ coordinates }) {
							return projection(coordinates)[1];
						})
						.on('click', function (e, d) {
							const yearData = data[years[currentYearIndex]];
							const otherBooks = yearData.filter((v) => v.name === d.name);
							console.log(
								otherBooks.length,
								otherBooks.map((x) => x.title)
							);
							count.textContent = `${otherBooks.length} książek o danym rejonie`
							bookTitle.textContent = years[currentYearIndex];
							
							const titles = document.getElementById("titles")
							const li = document.createElement("li")
							li.classList.add("text-hidden");
							const listLi = otherBooks.map(b => {
								const li = document.createElement("li")
								li.classList.add("text-hidden");
								li.textContent = b.title
								return li;
							})
							titles.innerHTML = ''
							listLi.forEach(li => {
								titles.appendChild(li)
							});
							description.appendChild;
							tag.textContent = d.name;
						})
						.on('mouseover', function (e) {
							prevFill = d3.select(this).attr('r');
							d3.select(this).attr('r', prevFill * 2.5);
						})
						.on('mouseout', function (e) {
							d3.select(this).attr('r', prevFill);
						})
						.attr('transform', transform)
						.attr('r', function (d) {
							const yearData = data[years[currentYearIndex]];
							const quantity = yearData.filter((v) => v.name === d.name).length;

							switch (true) {
								case quantity < 30:
									return circleSize;

									break;
								case quantity >= 30 && quantity < 70:
									return circleSize*1.25;

									break;
								case quantity >= 70:
									return circleSize*2.5

									break;
								default:
									return circleSize
									break;
							}
							return circleSize;
						})
						.attr('fill', function (d) {
							const yearData = data[years[currentYearIndex]];
							const quantity = yearData.filter((v) => v.name === d.name).length;

							switch (true) {
								case quantity < 30:
									return `url(#grad-cold)`;

									break;
								case quantity >= 30 && quantity < 70:
									return `url(#grad-medium)`;

									break;
								case quantity >= 70:
									return `url(#grad-hot)`;

									break;
								default:
									return `url(#grad-cold)`;
									break;
							}
							return 'transparent';
						});
				}
				setTimeout(() => {
					currentYearIndex += 1;
					getNextYear(element, years);
					currentTimeout = INITIAL_TIMEOUT;
				}, currentTimeout);
			};
			var width = 960,
				height = 500;

			var projection = d3.geoMercator().center([0, 50]).scale(550).rotate([0, 0]);

			var svg = d3
				.select('div.map-container')
				.append('svg')
				.attr('width', width)
				.attr('height', height)
				.attr('class', 'svg');

			var path = d3.geoPath().projection(projection);

			g = svg.append('g');
			var defs = svg.append('defs');

			const renderGradient = (data, id) =>
				defs
					.append('radialGradient')
					.attr('id', id)
					.selectAll('stop')
					.data(data)
					.enter()
					.append('stop')
					.attr('offset', function (d) {
						return d.offset;
					})
					.attr('stop-color', function (d) {
						return d.color;
					});

			renderGradient(
				[
					{ offset: '1%', color: '#fdef32a0' },
					{ offset: '5%', color: '#fd803201' },
					{ offset: '75%', color: '#fd803200' },
					{ offset: '100%', color: '#fd803200' }
				],
				'grad-hot'
			);
			renderGradient(
				[
					{ offset: '2%', color: '#db403515' },
					{ offset: '10%', color: '#db403501' },
					// { offset: '%', color: '#db403540' },
					{ offset: '100%', color: '#db403500' }
				],
				'grad-medium'
			);
			renderGradient(
				[
					{ offset: '1%', color: '#c89cffa0' },
					{ offset: '5%', color: '#b273ff01' },
					{ offset: '20%', color: '#8e47e600' }
				],
				'grad-cold'
			);
			// load and display the World
			d3.json('http://localhost:80/world-110m.json').then(function (topology) {
				g.selectAll('path')
					.data(topojson.feature(topology, topology.objects.countries).features)
					.enter()
					.append('path')
					.attr('d', path)
					.attr('class', 'countries');
			});

			var zoom = d3
				.zoom()
				.scaleExtent([0.25, 8])
				.on('zoom', function (event) {
					g.selectAll('path').attr('transform', event.transform);
					g.selectAll('circle')
						.attr('transform', event.transform)
						.attr('r', (CIRCLE_SIZE * 1) / event.transform.k);
					transform = event.transform;
				});

			// svg.call(
			// 	d3.drag().on('drag', function (event) {
			// 		var c = projection.rotate();
			// 		projection.rotate([c[0] + event.dx / 6, c[1] - event.dy / 6]);
			// 		svg.selectAll('path').attr('d', path);
			// 		svg.selectAll('.circles')
			// 			.attr('cx', function (d) {
			// 				var coords = projection([d.Longitude_imp, d.Latitude_imp]);
			// 				return coords[0];
			// 			})
			// 			.attr('cy', function (d) {
			// 				var coords = projection([d.Longitude_imp, d.Latitude_imp]);
			// 				return coords[1];
			// 			});

			// 		svg.selectAll('circle').style('display', function (d) {
			// 			var circle = [d.Longitude_imp, d.Latitude_imp];
			// 			var rotate = projection.rotate(); // antipode of actual rotational center.

			// 			var center = [-rotate[0], -rotate[1]];

			// 			var distance = d3.geoDistance(circle, center);
			// 			return distance > Math.PI / 2 ? 'none' : 'inline';
			// 		});
			// 	})
			// );

			svg.call(zoom);

			d3.json('http://localhost:80/db_books.json').then(function (dataJSON) {
				data = dataJSON;
				const years = Object.keys(dataJSON);
				points = years;

				window.data = dataJSON;

				getNextYear(currentYearElement, years);
			});
		</script>
	</body>
</html>
